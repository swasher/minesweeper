"""

–ö–û–†–û–ß–ï, –ù–£–ñ–ù–û –ü–†–ò–ô–¢–ò –ö –¢–ê–ö–û–ú–£ –°–û–ì–õ–ê–®–ï–ù–ò–Æ –í–û ==–í–°–ï–ú== –ü–†–û–ï–ö–¢–ï:

–ë–û–ú–ë–´ - (BOMBS) - –≠–¢–û –ê–°–°–ï–¢–´ (–ò –°–û–î–ï–†–ñ–ò–ú–û–ï) –Ø–ß–ï–ï–ö *–ü–û–°–õ–ï* –û–ö–û–ù–ß–ê–ù–ò–Ø –ò–ì–†–´, –ö–û–ì–î–ê –Æ–ó–ï–† –í–ó–û–†–í–ê–õ–°–Ø

–ú–ò–ù–´ (MINES) - –≠–¢–û –ë–û–ú–ë–´, –ö–û–¢–û–†–´–ï –ú–´ –ò–°–ü–û–õ–¨–ó–£–ï–ú –í –ò–ì–†–ï TK.

–°–æ–æ—Ç–≤,

cell.is_bomb - —ç—Ç–æ –µ—Å–ª–∏ –±–æ–º–±–∞ –ø–æ—Å–ª–µ –≤–∑—Ä—ã–≤–∞ (–≤ –∏–≥—Ä–µ —Å —ç–∫—Ä–∞–Ω–∞)
cell.is_mine - —ç—Ç–æ —Å–ø—Ä—è—Ç–∞–Ω–Ω–∞—è –≤ —è—á–µ–π–∫–µ –±–æ–º–±–∞ (–≤ —Å–µ—Ç–µ matrix.mines)

"""

# üí£üö©
# TODO –í Play mode –º–æ–∂–Ω–æ –ø–µ—Ä–µ–π—Ç–∏, —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –±—ã–ª –≤–∫–ª—é—á–µ–Ω bomb mode
# TODO –ü–æ—Å–ª–µ –∑–∞–≥—Ä—É–∑–∫–∏ Pickle —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞—Ç—å ??? —Ä–µ–∂–∏–º
# TODO –ü—Ä–∏ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–∏ –ø—Ä–æ–≤–µ—Ä—è—Ç—å –ø–æ–ª–µ –Ω–∞ –≤–∞–ª–∏–¥–Ω–æ—Å—Ç—å
# TODO –°–¥–µ–ª–∞—Ç—å —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π —Ä–µ–∂–∏–º –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –ø–æ–ª—è —Å –ø—Ä–æ–≤–µ—Ä–∫–∞–º–∏ –Ω–∞ –≤–∞–ª–∏–¥–Ω–æ—Å—Ç—å 

import pickle
from pathlib import Path
from win32gui import GetWindowRect, GetForegroundWindow
from enum import IntEnum
from dataclasses import dataclass

import tkinter as tk
from tkinter import filedialog, messagebox, simpledialog
from tktooltip import ToolTip

import asset
from matrix import Matrix
from cell import Cell


class Mode(IntEnum):
    play = 0
    edit = 1


class State(IntEnum):
    playing = 0
    win = 1
    fail = 2


class Mouse(IntEnum):
    left = 0
    right = 1
    both = 2


@dataclass
class Game:
    width: int
    height: int
    bombs: int


beginner = Game(9, 9, 10)
intermediate = Game(16, 16, 40)
expert = Game(30, 16, 99)
default_game = beginner

# config.assets =

# asset_dir = 'asset/asset_svg/'
asset_dir = Path(__file__).resolve().parent / 'asset' / 'asset_svg'


class MinesweeperApp:
    def __init__(self, root):
        self.root = root
        self.root.geometry("300x300")

        self.grid_width = default_game.width
        self.grid_height = default_game.height
        self.px = 24  # —Ä–∞–∑–º–µ—Ä —è—á–µ–π–∫–∏ –≤ px
        self.root.title(f"Minesweeper {self.grid_width}x{self.grid_height}")

        self.matrix = Matrix()  # we need matrix initialized matrix for create status bar
        self.matrix.initialize_without_screen(height=self.grid_height, width=self.grid_width)
        self.matrix.create_new_game(n_bombs=10)

        self.buttons = {}
        self.mode = Mode.edit
        self.state = State.playing
        self.mines_is_known = True
        self.load_images()

        self.create_status_bar()
        self.create_menu()
        self.grid_frame = tk.Frame(self.root)
        self.create_grid()
        self.create_sidebar()

        self.start_new_game(game=beginner)

    def load_images(self):
        self.images = {
            "closed": tk.PhotoImage(file=asset.closed.filename),
            "bomb": tk.PhotoImage(file=asset.bomb.filename),
            "bomb_red": tk.PhotoImage(file=asset.bomb_red.filename),
            "bomb_wrong": tk.PhotoImage(file=asset.bomb_wrong.filename),
            "flag": tk.PhotoImage(file=asset.flag.filename),
            "there_is_bomb": tk.PhotoImage(file=asset.there_is_bomb.filename),
            "0": tk.PhotoImage(file=asset.n0.filename),
            "1": tk.PhotoImage(file=asset.n1.filename),
            "2": tk.PhotoImage(file=asset.n2.filename),
            "3": tk.PhotoImage(file=asset.n3.filename),
            "4": tk.PhotoImage(file=asset.n4.filename),
            "5": tk.PhotoImage(file=asset.n5.filename),
            "6": tk.PhotoImage(file=asset.n6.filename),
            "7": tk.PhotoImage(file=asset.n7.filename),
            "8": tk.PhotoImage(file=asset.n8.filename),
        }

    def create_menu(self):
        menu = tk.Menu(self.root)
        self.root.config(menu=menu)
        file_menu = tk.Menu(menu, tearoff=0)
        menu.add_cascade(label="File", menu=file_menu)
        file_menu.add_command(label="Save matrix", command=self.save_matrix)
        file_menu.add_command(label="Load matrix", command=self.load_matrix)
        file_menu.add_separator()
        file_menu.add_command(label="Exit", command=self.root.quit)

        size_menu = tk.Menu(menu, tearoff=0)
        menu.add_cascade(label="New game", menu=size_menu)
        size_menu.add_command(label="Beginner (9x9)", command=lambda: self.start_new_game(game=beginner))
        size_menu.add_command(label="Intermediate (16x16)", command=lambda: self.start_new_game(game=intermediate))
        size_menu.add_command(label="Expert (30x16)", command=lambda: self.start_new_game(game=expert))
        size_menu.add_command(label="Custom", command=self.start_new_game)

    def create_sidebar(self):
        self.sidebar = tk.Frame(self.root, width=83, padx=3, bg='lightgrey')
        self.sidebar.grid(row=0, column=0, rowspan=self.grid_height, sticky='ns')
        self.sidebar.grid_propagate(False)  # Prevent the sidebar from resizing based on its children

        self.edit_button = tk.Button(master=self.sidebar, text="Edit mode", command=lambda: self.set_mode(Mode.edit))
        self.edit_button.grid(row=0, column=0, pady=5)
        ToolTip(self.edit_button, msg="–î–ª—è Edit Mode –Ω—É–∂–Ω–æ —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Å–æ–æ—Ç–≤. Bomb Mode")

        # self.label_mik = tk.Label(self.sidebar, text="Bomb mode:")
        # self.label_mik.grid(row=1, column=0, pady=5)

        self.checkbutton_mik = tk.Checkbutton(master=self.sidebar, text="", command=self.update_mines_is_known)
        self.checkbutton_mik.grid(row=2, column=0, pady=5)
        ToolTip(self.checkbutton_mik, msg="Mines is known. ON - –ú—ã —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –±–æ–º–±—ã, —Ü–∏—Ñ—Ä—ã —Å—Ç–∞–≤—è—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏."
                                          " OFF - –ú—ã —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ü–∏—Ñ—Ä—ã, –ø–æ–ª–æ–∂–µ–Ω–∏–µ –±–æ–º–± –≤ –º–∞—Ç—Ä–∏—Ü–µ –Ω–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–æ")
        self.checkbutton_mik.select() if self.checkbutton_mik else self.checkbutton_mik.deselect()

        self.label_mik_mode = tk.Label(self.sidebar, text="(Set Bombs)")
        self.label_mik_mode.grid(row=3, column=0, pady=5)

        self.play_button = tk.Button(master=self.sidebar, text="Play mode", command=lambda: self.set_mode(Mode.play))
        self.play_button.grid(row=4, column=0, pady=5)
        ToolTip(self.play_button, msg="–í—ã—Ö–æ–¥–∏–º –∏–∑ —Ä–µ–∂–∏–º–∞ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è, –∏ –º–æ–∂–µ–º '–∏–≥—Ä–∞—Ç—å' –≤ —Ç–µ–∫—É—â–µ–µ –ø–æ–ª–µ")

        if self.mode == Mode.edit:
            self.edit_button.config(font=("Helvetica", 10, "bold"))
            self.play_button.config(font=("Helvetica", 10, "normal"))
        elif self.mode == Mode.play:
            self.edit_button.config(font=("Helvetica", 10, "normal"))
            self.play_button.config(font=("Helvetica", 10, "bold"))

    def create_status_bar(self):
        self.status_bar_frame = tk.Frame(self.root)
        self.status_bar_frame.grid(row=1, column=1, sticky='ns')
        self.status_bar = tk.Label(self.status_bar_frame, text="", bd=1, relief=tk.SUNKEN, anchor=tk.W)
        self.status_bar.grid(row=1, column=0, columnspan=2, sticky='we')

    def create_grid(self):
        # Clear existing buttons
        for widget in self.grid_frame.winfo_children():
            widget.destroy()

        self.grid_frame.grid(row=0, column=1, sticky='nw')

        for x in range(self.grid_height):
            for y in range(self.grid_width):
                btn = tk.Button(self.grid_frame,
                                # command=lambda x=x, y=y: self.click_cell(x, y, 'aaa'),
                                image=self.images["closed"],
                                highlightthickness=0,
                                borderwidth=0,
                                )
                btn.bind("<Button-1>", lambda event, x=x, y=y: self.click_cell(event, x, y, Mouse.left))
                btn.bind("<Button-3>", lambda event, x=x, y=y: self.click_cell(event, x, y, Mouse.right))
                btn.grid(row=x, column=y)
                self.buttons[(x, y)] = btn

    def update_status_bar(self):
        if self.get_state == State.win:
            self.status_bar.config(text="You win!")
        elif self.get_state == State.fail:
            self.status_bar.config(text="You lose!")
        else:
            closed_count = len(self.matrix.get_closed_cells())
            mine_count = len(self.matrix.get_mined_cells())
            opened_count = len(self.matrix.get_open_cells())
            flag_count = len(self.matrix.get_flag_cells())
            self.status_bar.config(text=f"Closed:{closed_count}, Mines:{mine_count}, Open:{opened_count}, Flags:{flag_count}")

    def update_grid(self):
        """
        –û–±–Ω–æ–≤–ª—è–µ—Ç –≤–∏–∑—É–∞–ª—å–Ω–æ–µ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –≤ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–∏ —Å –æ–±—ä–µ–∫—Ç–æ–º Matrix
        """
        for x in range(self.grid_height):
            for y in range(self.grid_width):

                # TODO –µ—Å–ª–∏ —è—á–µ–π–∫–∞ –£–ñ–ï —Å–æ–æ—Ç–≤. –º–∞—Ç—Ä–∏—Ü–µ, –Ω–µ –Ω—É–∂–Ω–æ –µ–µ –æ–±–Ω–æ–≤–ª—è—Ç—å, —ç—Ç–æ —Ç–æ–ª—å–∫–æ –æ—Ç–Ω–∏–º–∞–µ—Ç –ø—Ä–æ—Ü–µ—Å—Å–æ—Ä–Ω–æ–µ –≤—Ä–µ–º—è

                cell = self.matrix.table[x][y]
                image_name = cell.asset.name
                button = self.buttons[(x, y)]

                if image_name in self.images:

                    if (self.mode == Mode.edit and self.mines_is_known is True
                            and cell.is_closed and cell.is_mine):
                        img = self.images['there_is_bomb']
                    else:
                        img = self.images[image_name]

                    button.config(image=img)
                else:
                    raise Exception(f"Image not found: {image_name}")

        self.update_status_bar()

    def update_mines_is_known(self):
        if self.mines_is_known:
            response = messagebox.askyesno("Warning",
                                           "–≠—Ç–æ —É–¥–∞–ª–∏—Ç –≤—Å–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—ã–µ –º–∏–Ω—ã —Å –ø–æ–ª—è.")
            if response:
                self.mines_is_known = not self.mines_is_known
                self.checkbutton_mik.deselect()
                self.switch_to_mik_off()
        else:
            response = messagebox.askyesno("Warning",
                                           "–í—Å–µ —Ü–∏—Ñ—Ä—ã —Å—Ç–∞–Ω—É—Ç –ø—Ä–æ—Å—Ç–æ –æ—Ç–∫—Ä—ã—Ç—ã–º–∏ —è—á–µ–π–∫–∞–º–∏ (0). –ú–æ–∂–Ω–æ —Ä–∞—Å—Å—Ç–∞–≤–∏—Ç—å –±–æ–º–±—ã")
            if response:
                self.mines_is_known = not self.mines_is_known
                self.checkbutton_mik.select()
                self.switch_to_mik_on()

    def switch_to_mik_on(self):
        """
        –ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ –≤ —Ä–µ–∂–∏–º "—Ä–∞—Å—Å—Ç–∞–Ω–æ–≤–∫–∞ –±–æ–º–±"
        """
        # –∑–Ω–∞—á–∏—Ç, —É –Ω–∞—Å –¥–∞–Ω–∞ –º–∞—Ç—Ä–∏—Ü–∞ —Å –∑–∞–∫—Ä—ã—Ç—ã–º–∏ —è—á–µ–π–∫–∞–º–∏ –∏ —á–∏—Å–ª–∞–º–∏....
        # –Ω–∞–º –Ω—É–∂–Ω–æ –≤—Å–µ —á–∏—Å–ª–∞ –ø—Ä–µ–≤—Ä–∞—Ç–∏—Ç—å –≤ n0
        digits = self.matrix.get_digit_cells()
        for d in digits:
            d.asset = asset.n0

        self.label_mik_mode.config(text="(Set Bombs)")

        self.update_grid()

    def switch_to_mik_off(self):
        """
        –ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ –≤ —Ä–µ–∂–∏–º "—Ä–∞—Å—Å—Ç–∞–Ω–æ–≤–∫–∞ —á–∏—Å–µ–ª"
        """
        # –ù–∞–º –Ω—É–∂–Ω–æ —É–±—Ä–∞—Ç—å –≤—Å–µ "—É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—ã–µ –±–æ–º–±—ã"
        self.matrix.mines = set()
        self.label_mik_mode.config(text="(Set Digits)")
        self.update_grid()

    def set_mode(self, mode):
        self.mode = mode
        print(f"Mode set to: {self.mode.name}")

        # Update button fonts
        if self.mode == Mode.edit:
            self.edit_button.config(font=("Helvetica", 10, "bold"))
            self.play_button.config(font=("Helvetica", 10, "normal"))
            self.images["there_is_bomb"] = tk.PhotoImage(file=asset_dir.joinpath("there_is_bomb.png"))
        elif self.mode == Mode.play:
            self.edit_button.config(font=("Helvetica", 10, "normal"))
            self.play_button.config(font=("Helvetica", 10, "bold"))
            self.images["there_is_bomb"] = tk.PhotoImage(file=asset_dir.joinpath("closed.png"))
        self.update_grid()

    def start_new_game(self, game: Game = None):
        if not game:
            size = simpledialog.askstring("Custom Size", "Enter width, height and bombs (e.g., 30x16x99):")
            try:
                width, height, bombs = map(int, size.split('x'))
                game = Game(width, height, bombs)
            except ValueError:
                messagebox.showerror("Invalid Input", "Please enter valid ints separated by 'x'.")

        self.set_custom_size(game)
        self.matrix = Matrix()
        self.matrix.initialize_without_screen(self.grid_width, self.grid_height)
        self.matrix.create_new_game(n_bombs=game.bombs)

        self.set_state(State.playing)
        self.update_grid()
        # self.matrix.display()

    def set_custom_size(self, game: Game = None):
        """
        Size is string like "10x5"
        """
        width, height, bombs = game.width, game.height, game.bombs

        if 1 <= width <= 50 and 1 <= height <= 50:

            self.grid_width = width
            self.grid_height = height
            self.create_grid()

            self.root.update_idletasks()  # Ensure the grid is created before resizing
            geom_x = self.px * width + self.sidebar.winfo_width()
            geom_y = self.px * height + self.status_bar_frame.winfo_height()
            geom_x = max(geom_x, 250)
            # geom_y = max(geom_y, 80)
            self.root.geometry(f"{geom_x}x{geom_y}")
            self.root.title(f"Minesweeper {self.grid_width}x{self.grid_height}")
            print(f'Successfully set grid size to {width}x{height} and window to {geom_x}x{geom_y}')
        else:
            messagebox.showerror("Invalid Size", "Width and height must be between 1 and 50.")

    def click_cell(self, event, x: int, y: int, button: Mouse):
        if self.get_state == State.playing:
            # print(f'Clicked: {button.name}')
            if self.mode == Mode.play:
                # –º—ã –Ω–µ –º–æ–∂–µ–º "–ø–µ—Ä–µ–∫–ª—é—á–∞—Ç—å" —è—á–µ–π–∫–∏, –∞ —Ç–æ–ª—å–∫–æ "–æ—Ç–∫—Ä—ã–≤–∞—Ç—å" –∏—Ö, –∞ –Ω–∞ –∑–∞–∫—Ä—ã—Ç—ã–µ —Å—Ç–∞–≤–∏—Ç —Ñ–ª–∞–≥.
                # –ù—É–∂–Ω–∞ –ª–æ–≥–∏–∫–∞ –æ—Ç–∫—Ä—ã—Ç–∏—è —Å–≤—è–∑–∞–Ω–Ω—ã—Ö —è—á–µ–µ–∫.
                # –ï—Å–ª–∏ –Ω–∞–∂–∞–ª–∏ –±–æ–º–±—É, —Ç–æ –∏–≥—Ä–∞ –∑–∞–∫–∞–Ω—á–∏–≤–∞–µ—Ç—Å—è.
                self.play_cell(x, y, button)
                # self.matrix.display()
            elif self.mode == Mode.edit:
                # –í —Ä–µ–∂–∏–º–µ Mines is known - ON –º—ã –ø—Ä–æ—Å—Ç–æ –ø–µ—Ä–µ–∫–ª—é—á–∞–µ–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ —è—á–µ–π–∫–∏, –≤–∫–ª—é—á–∞—è —Å–∫—Ä—ã—Ç—É—é –±–æ–º–±—É. –ü—Ä–∏ —ç—Ç–æ–º –æ–±–Ω–æ–≤–ª—è–µ–º —Ü–∏—Ñ—Ä—ã –≤–æ–∫—Ä—É–≥.
                # –í —Ä–µ–∂–∏–º–µ Mines is known - OFF –º—ã –ø–µ—Ä–µ–∫–ª—é—á–∞–µ–º —Ü–∏—Ñ—Ä—ã –≤ –ø—É—Å—Ç—ã—Ö —è—á–µ–π–∫–∞—Ö
                if self.mines_is_known:
                    self.edit_cell_bomb_mode(x, y, button)
                else:
                    self.edit_cell_digit_mode(x, y, button)

            self.update_grid()
            self.update_status_bar()

    def play_cell(self, x, y, button):
        current_cell = self.matrix.table[x][y]

        if button == Mouse.left:
            fail = self.matrix.play_left_button(current_cell)
        elif button == Mouse.right:
            fail = self.matrix.play_right_button(current_cell)
        else:
            raise Exception('Unknown button')

        if fail:
            print('FAIL')
            self.set_state(State.fail)
        else:
            if len(self.matrix.get_closed_cells()) == 0:
                self.set_state(State.win)
                print('WIN')

    #
    # –í –ú–ê–ô–ù.–¢–ö –û–°–¢–ê–õ–û–°–¨ –ü–†–û–í–ï–†–ò–¢–¨ –¢–û–õ–¨–ö–û –≠–¢–ò –î–í–ê –ú–ï–¢–û–î–ê
    # –û–°–¢–ê–õ–¨–ù–û–ï –í –õ–û–ì–ò–ö–ï MATRIX play_left_button –ò play_right_button
    #

    def edit_cell_bomb_mode(self, x, y, button):
        """
        —Ç—É—Ç –Ω–µ–º–Ω–æ–≥–æ –≥–æ–≤–Ω–æ-–∫–æ–¥. –ü–æ—Ç–æ–º—É —á—Ç–æ –Ω–∞–º –Ω—É–∂–Ω–æ –∏—Ç–µ—Ä–∏—Ä–æ–≤–∞—Ç—å —Å–æ—Å—Ç–æ—è–Ω–∏–µ —è—á–µ–π–∫–∏ –ø–æ –Ω–µ—Å–∫–æ–ª—å–∫–∏–º –∞—Å—Å–µ—Ç–∞–º –ü–õ–Æ–°
        –∑–∞–∫—Ä—ã—Ç–∞—è —è—á–µ–π–∫–∞ —Å –±–æ–º–±–æ–π. –î–ª—è —ç—Ç–æ–≥–æ –≤–≤–µ–¥–µ–Ω –ø—Å–µ–≤–¥–æ-–∞—Å—Å–µ—Ç there_is_bomb, –∫–æ—Ç–æ—Ä—ã–π –Ω–∞ —Å–∞–º–æ–º –¥–µ–ª–µ —è–≤–ª—è–µ—Ç—Å—è
        –ó–ê–ö–†–´–¢–û–ô –Ø–ß–ï–ô–ö–û–ô –ø–ª—é—Å –º–∏–Ω–∞ –≤ matrix.mines.
        """
        cell: Cell = self.matrix.table[x][y]
        current_asset = self.matrix.table[x][y].asset
        is_mined = cell.is_mine
        print('Mined?', is_mined)
        print('Before match cell is:', cell, cell.asset)

        match current_asset, is_mined, button:
            case asset.closed, False, Mouse.left:
                print('left1')
                # –∑–∞–∫—Ä—ã—Ç–∞—è - —Å—Ç–∞–≤–∏–º –º–∏–Ω—É (–∞—Å—Å–µ—Ç –ø—Ä–∏ —ç—Ç–æ–º –Ω–µ –º–µ–Ω—è–µ—Ç—Å—è - –æ—Å—Ç–∞–µ—Ç—Å—è closed)
                cell.set_mine()
            case asset.closed, True, Mouse.left:
                print('left2')
                # –º–∏–Ω–∞ -> –æ—Ç–∫—Ä—ã–≤–∞–µ–º
                cell.remove_mine()
                cell.asset = asset.n0
            case _, False, Mouse.left:
                print('left3')
                # –æ—Ç–∫—Ä—ã—Ç–∞—è -> –∑–∞–∫—Ä—ã–≤–∞–µ–º
                cell.asset = asset.closed
            case asset.flag, _, Mouse.right:
                print('right1')
                cell.remove_flag()
            case asset.closed, _, Mouse.right:
                print('right2')
                cell.set_flag()

        # –æ–±–Ω–æ–≤–ª—è–µ–º —Ü–∏—Ñ—Ä—ã –≤–æ–∫—Ä—É–≥
        cells_to_update = self.matrix.around_opened_cells(cell)
        for c in cells_to_update:
            mines = len(self.matrix.around_mined_cells(c))
            c.asset = asset.open_cells[mines]

        # –∏ –≤ —Å–∞–º–æ–π —è—á–µ–π–∫–µ (–µ—Å–ª–∏ –æ–Ω–∞ –æ—Ç–∫—Ä—ã–ª–∞—Å—å)
        if cell.is_empty:
            mines = len(self.matrix.around_mined_cells(cell))
            cell.asset = asset.open_cells[mines]

        print('After match cell is:', cell, cell.asset)

    def edit_cell_digit_mode(self, x, y, button):
        if button == Mouse.left:
            cell_toggle_list = [asset.closed, asset.n0, asset.n1, asset.n2, asset.n3, asset.n4, asset.n5, asset.n6, asset.n7, asset.n8]
        elif button == Mouse.right:
            cell_toggle_list = [asset.closed, asset.flag]
        else:
            raise Exception('Unknown button')

        current_asset = self.matrix.table[x][y].asset

        # Find the index of c in the list
        try:
            current_index = cell_toggle_list.index(current_asset)
        except ValueError:
            current_index = 0
        # Calculate the next index, wrapping around if necessary
        next_index = (current_index + 1) % len(cell_toggle_list)
        # Get the next item
        next_item = cell_toggle_list[next_index]

        self.matrix.table[x][y].asset = next_item

    def set_state(self, state: State):
        self.state = state

    @property
    def get_state(self):
        return self.state

    def save_matrix(self):

        # method 1
        # w, h = self.root.winfo_reqwidth(), self.root.winfo_reqheight()
        # x, y = self.root.winfo_rootx(), self.root.winfo_rootx()

        # method 2
        # coordinates = self.root.geometry()
        # size, x, y = coordinates.split('+')
        # x, y = int(x), int(y)
        # w, h = map(int, size.split('x'))
        # print(coordinates)
        # print(w, h)
        # print(x, y)

        # method 3
        (x1, y1, x2, y2) = GetWindowRect(GetForegroundWindow())

        # -----------
        # remove 9 px as shadow
        self.matrix.region_x1 = x1+9
        self.matrix.region_y1 = y1
        self.matrix.region_x2 = x2-9
        self.matrix.region_y2 = y2-9
        self.matrix.save()

    def load_matrix(self):
        file_path = filedialog.askopenfilename(filetypes=[("Pickle files", "*.pickle")])
        if file_path:
            with open(file_path, 'rb') as inp:
                self.matrix = pickle.load(inp)
                self.matrix.display()

            w, h = self.matrix.width, self.matrix.height
            g = Game(w, h, bombs=0)
            self.set_custom_size(g)
            self.update_grid()
            print("Field loaded successfully!")


if __name__ == "__main__":
    root = tk.Tk()
    app = MinesweeperApp(root)
    root.mainloop()
