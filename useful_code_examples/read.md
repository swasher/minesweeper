Как я упоминал ранее, есть некоторые улучшения, которые могут быть внесены в алгоритм, впервые упомянутый автором выше.
Сначала, когда вы разделяете граничные плитки (я называю это созданием последовательности связанных плиток) и переходите
к созданию решений для каждой последовательности, ограничьте количество мин, разрешенных текущим количеством мин, минус
количество последовательностей плюс 1. Конечно, когда в конце play у вас будет одна последовательность, поэтому вы
ограничите как максимальное, так и минимальное количество мин до фактического количества мин.

А теперь перейдем ко второй, более интересной части. Если сумма максимальных мин, используемых для всех
последовательностей, превышает количество мин, вы можете вернуться и перепроверить возможные решения, уменьшив
максимальный предел. Например, предположим, что мы нашли три последовательности с минимальным и максимальным количеством
мин (2,2), (11,13) и (2,2), но осталось только 15 мин. Поэтому мы перепроверяем решения для второй последовательности,
ограничивая ее 11 мин. Или предположим, что вы нашли четыре последовательности с минимальным и максимальным количеством
мин: (1,1), (4,6), (6,8) и (1,1), но осталось только 13 мин. Это означает, что у нас не может быть ни второй
последовательности, использующей 6 мин, ни третьей последовательности, использующей 8 мин. Итак, теперь мы можем
вернуться и повторно протестировать эти две последовательности, используя максимум 5 и 7 соответственно.

Третья оптимизация происходит, когда у нас есть ситуации, когда последовательности занимают все оставшиеся
неэкспонированные записи в головоломке, но завершение воспроизведения еще не запущено, и существует более одной
последовательности и min! = Max. Например, у нас есть две последовательности с минимальным и максимальным количеством
мин (5,6) и (2,3) с оставшимися 8 мин. В первой последовательности есть 4 решения, а во второй - 3 решения, и нет
очевидного выбора, где играть. Однако, если мы объединим две последовательности в одну и вызовем end play, мы обнаружим,
что есть 8 решений, но одно место имеет 0% шансов на мину!

Это приводит к очевидному правилу, которое не упоминалось выше. После использования танкового метода, если у вас есть
какой-либо вход с вероятностью 100% мины или 0% вероятности мины, тогда сделайте очевидный выбор.

Однако, если у вас есть одинаковый выбор между двумя или более локациями, есть причины выбрать одно из них. В
приведенном выше примере автора, где есть несколько мест со счетом до двух, я вижу два места, где я бы играл поверх
остальных. Каждый раз, когда у вас есть три плитки в строке или столбце, часто лучше играть в середине, рядом с ними,
чтобы, если одна из них отображается, мы могли бы сделать очевидный выбор, чтобы открыть целых три других плитки.
Однако, если вы выбрали диагональные позиции, вам поможет несколько значений. Итак, моя четвертая оптимизация. У меня
есть метод оценки, который я не буду вдаваться в подробности, но он выбирает наиболее вероятные места.

Одна оптимизация, которую я не делал, - это раскрытие шахты там, где это более вероятно, чем раскрытие не-шахтной
записи. Я также не заглядывал вперед (если я поставлю мину здесь, это поможет сделать очевидный выбор). Я рассмотрю это
позже.

У меня также есть второй метод предположений, который не использует танковый метод, и я опишу его в какой-то момент в
будущем.

Я забыл упомянуть, что исходные 6000 прогонов проб используют некоторые начальные параметры, которые могут быть
неоптимальными (start = 3,3 endplay = 14, offset = -. 03). Я объясню эти числа позже.

Я работаю над этой программой и каждый день нахожу ошибки или улучшения. Когда я закончу, я опубликую более точные
цифры. А пока пытаюсь выяснить, почему одни стартовые позиции дают лучшие результаты, чем другие.

Как я уже упоминал, можно использовать еще один тип предположений. Я называю эту версию guess1, а предыдущую версию -
guess2. В любом случае, когда вы создаете связанные последовательности записей, необходимые для метода резервуара,
сохраняйте минимальное и максимальное количество мин, используемых для каждой последовательности. Теперь любые
оставшиеся неэкспонированные записи за вычетом любых записей в списке последовательностей можно использовать для
создания нового списка, который я называю свободным списком. Оцените количество мин в этой свободной области, взяв
сумму (мин. + Макс.) / 2 мин для каждой последовательности. Теперь шансы получить мину в свободной зоне - это количество
свободных входов, деленное на оценку мин. Теперь, если эти шансы ниже, чем наилучшее предположение с использованием
метода танка, вы можете вместо этого использовать guess1.

Если вы действительно используете guess1, вы можете пойти двумя разными путями. Вы можете выбрать запись рядом с
последовательностью, чтобы помочь поддержать любую последовательность. Это первый выбор, потому что вы, вероятно,
получите некоторую помощь, которая поможет решить большую часть головоломки. Я ищу ситуации, которые выглядят так:
XXX
- - -
? Я выберу? вход, даже если одна из позиций X не на грани. На самом деле мой метод немного сложнее этого, но я опущу
детали. Если я не могу найти ни одной из этих ситуаций, я постараюсь найти бесплатную запись с наименьшим количеством
бесплатных записей вокруг нее. Цель состоит в том, чтобы обнажить территорию без мин. Это почти всегда угол, но если их
взять, то подойдет и край. Я не буду заполнять вход, окруженный минами, если нет 100% вероятности, что это не мина.

Поскольку шансы для guess1 - это всего лишь оценка, я добавил смещение к шансам, чтобы попытаться оптимизировать лучшее
время для его использования. Я называю это «мое предположение1 выключено», и после выполнения 12 000 образцов результаты
показаны в следующей таблице. Поэтому я решил использовать -3%. Это означает, что если шансы шахты в свободной зоне
минус 3% меньше, чем шансы с использованием guess2, то мы используем guess1. 
Average Percent Std. Dev. 
—————————————————————————
-0,06 46,50% 0,42% 
-0,05 46,70% 0,43% 
-0,04 46,70% 0,43% 
-0,03 46,77% 0,43% 
-0,02 46,57% 0,43%

Далее я предоставлю информацию о наилучшем значении «end play», которое представляет собой количество оставшихся
записей, прежде чем мы вызовем метод end play.

Кстати, указанные автором 50% имеют стандартное отклонение 6,2% для 67 образцов, которые он использовал. Так что да, ему
повезло.